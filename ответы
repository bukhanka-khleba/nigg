1)Основное отличие композиции от агрегации:  
Композиция  подразумевает, что объект-часть (Part) жёстко связан с объектом-целым (Whole). Время жизни Part зависит от времени жизни Whole.
Агрегация  означает более слабую связь:объект-часть может существовать независимо от объекта-целого.
2)
#include <iostream>
#include <string>

class Part {
public:
    void display() const {
        std::cout << "Part is part of Whole\n";
    }
};

class Whole {
private:
    Part part; // Part является частью Whole и управляется им
public:
    void display() const {
        part.display();
    }
};

int main() {
    Whole whole;
    whole.display(); // Part существует только в контексте Whole
    return 0;
}
3)В агрегации объект-часть может существовать независимо от объекта-целого, что делает связь менее строгой.
  Пример использования агрегации:  Когда объекты могут быть переиспользованы или переданы между разными объектами-целыми (например, сотрудники и отделы в компании).
4) Мощность  определяет количество объектов-частей, связанных с объектом-целым.
Фиксированная мощность:  Используется, когда количество частей известно заранее.
1. class Whole {
private:
    Part parts[3]; // Фиксированное количество частей
};

2. #include <vector>
class Whole {
private:
    std::vector<Part> parts; // Динамическое количество частей
public:
    void addPartДвунаправленная ассоциация:  Оба объекта знают друг о друге.(const Part& part) {
        parts.push_back(part);
    }
};
5) Односторонняя ассоциация:  Один объект знает о другом, но не наоборот.
class A {
public:
    void useB(B* b) { /* A использует B */ }
};
Двунаправленная ассоциация:  Оба объекта знают друг о друге.

class A;
class B {
public:
    A* a;
};
class A {
public:
    B* b;
};
